<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Seph's Blog]]></title>
  <link href="http://sephhh.github.io/atom.xml" rel="self"/>
  <link href="http://sephhh.github.io/"/>
  <updated>2015-04-15T21:24:02-04:00</updated>
  <id>http://sephhh.github.io/</id>
  <author>
    <name><![CDATA[Seph Kramer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[My First Post on Octopress]]></title>
    <link href="http://sephhh.github.io/blog/2015/04/15/my-first-post-on-octopress/"/>
    <updated>2015-04-15T16:50:22-04:00</updated>
    <id>http://sephhh.github.io/blog/2015/04/15/my-first-post-on-octopress</id>
    <content type="html"><![CDATA[<p>Or-Equals (||= also known as &ldquo;pipes-equals&rdquo;) is one of my favorite Ruby expressions I&rsquo;ve encountered so far. It strikes me as sort of polite and considerate&ndash;not as pushy and uncompromising as other Ruby methods. Plus it comes in handy all the time. Let me explain how it works and why it can be so useful.</p>

<p>||= basically checks to see if a variable has something assigned to it besides nil or false. If it does, it stops right there and just leaves it be. If it doesn&rsquo;t, it assigns the variable a new value, whatever you supply on the right side of the expression.</p>

<p>So x ||= 10 checks x. If x is nil or false, it assigns x a value of 10. If x already has a value, ||= politely moves on without disturbing x at all. Here&rsquo;s where I imagine a sheepish Woody Allen voice&hellip; &ldquo;uh um sorry to trouble you but uh, if I may, just um, if you don&rsquo;t have a value already I have this other value for you and well um&hellip; you know, you can have it if you don&rsquo;t have one already.&rdquo;</p>

<p>To explain it more precisely, x ||= 10 is basically shorthand for x || x = 10. When Ruby looks at an or statement like this, it evaluates the first expression on the left, and if that expression evaluates to True, it doesn&rsquo;t bother looking at the right half, because it only takes one true expression to know that an or statement is true.</p>

<p>There are two subtleties to note here. One, note that this is a little different from how other similar looking expressions work.
x += 10
is the same as
x = (x+ 10)
n
but x ||= 10</p>

<p>is NOT the same as</p>

<p>x = (x || 10)</p>

<p>rather x ||= 10 is more like</p>

<p>x || (x = 10)</p>

<p>The difference is..</p>

<p>Another caveat&ndash;technically x||= 10 is not EXACTLY like x || (x = 10). In certain very specific scenarios they behave slightly differently (basically, blah, more details here).</p>

<p>When is ||= useful? All the time! I find myself using it when iterating through a collection that might have repeats. It&rsquo;s great for setting up a counter too. For example, say we want sort through and count a bunch of pants. Each pair of pants is represented by a hash like this:</p>

<p>{type: jeans, color: blue}</p>

<p>And say we want to combine a bunch of these hashes into a more organized hash like this:</p>

<p>{
jeans: [{color: blue, count: 3}]</p>

<p>slacks: [{color: black, count: 2}, {color: khaki, count: 1}]</p>

<p>sweats: [color: gray, count: 1]
}</p>

<p>useful for aggregating&ndash;create an array or key-value pair if it doesn&rsquo;t exist, and add to it.</p>

<p>(useful case 1)</p>

<p>(explain memoization and show useful case 2)</p>
]]></content>
  </entry>
  
</feed>
